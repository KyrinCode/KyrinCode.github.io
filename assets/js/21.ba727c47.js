(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{645:function(t,e,l){"use strict";l.r(e);var a=l(4),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,l=t._self._c||e;return l("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[l("p",[t._v("在设计区块链系统的时候，提高通量，不能仅仅地扩大区块的容量，也不能简单地缩短出块间隔，因为这样都会导致分叉情况更糟。")]),t._v(" "),l("p",[t._v("这篇文章的提高通量的角度是：")]),t._v(" "),l("ol",[l("li",[t._v("确定在某一区块高度是否是唯一的区块（也就是此高度没有分叉）如果是唯一的话，就代表这区块往前的所有高度的区块都是被确认的了。具体来说，首先假设有一个指标delta代表区块链网络传播时间上限（就是一个节点发出到最后一个节点收到的时间），那么：一个节点收到一个区块的时间为t，delta时间后，保证全网都收到了这个区块，在t ~ t+delta这个区间可能会有其他节点广播同一高度的区块，这最迟会在t+2delta时被全网节点收到。也就是说在t+2delta时刻如果仅收到过一个区块，则这个区块就是该高度的唯一区块，可以认为之前的交易全部被确认。")]),t._v(" "),l("li",[t._v("优化出块间隔时间，使唯一的区块出现的速度最快，充分利用算力。在全局的角度来看，刚刚的可以这样理解，如果第B+1个区块挖出与第B个区块挖出的时间间隔 t~B+1~ - t~B~ > delta 且第B个区块挖出与第B-1个区块挖出的时间间隔 t~B~ - t~B-1~ > delta，那么第B个区块就是该高度唯一区块，这之前的交易都可以看作被确认。现在的目的就是让这样同高度唯一的区块出现的速度最快，各种推公式之后得到了一个动态调节的出块间隔时间。")])]),t._v(" "),l("p",[t._v("问题：后面文章还提及了对于区块大小的计算，根据delta和算出的出块间隔时间得到的平均每个区块中该存储的交易数量，再考虑到出现某时间的交易峰值，应将实际区块大小设置为5 ~ 10倍，感觉这个部分就不太科学，首先区块大小就会影响网络传播时间上限delta，然后这个粗糙的估计就感觉是为了加这部分内容强行写的，所以我认为重点还是前面那俩思想。")])])}),[],!1,null,null,null);e.default=n.exports}}]);